# Eligibility Check System - Robust AI-Driven Redesign

## Problem Analysis

You're absolutely right - the pattern library approach I implemented is **fundamentally flawed** because:

1. **Brittleness**: Hardcoded patterns break with new medical terminology or criteria formats
2. **Loss of Flexibility**: The AI's ability to interpret novel criteria is handicapped
3. **Maintenance Burden**: Constant updates needed for new trial criteria patterns
4. **Against Design Philosophy**: The system was intentionally designed to be AI-driven

## Current Hardcoded Elements to Remove/Improve

### 1. Pattern Library (REMOVE)
- **File**: `/lib/eligibility-checker/question-patterns.ts`
- **Issue**: 40+ hardcoded patterns that will break with new criteria
- **Solution**: Delete this file, rely on AI interpretation

### 2. Medical Terms Dictionary (KEEP BUT ENHANCE)
- **Current**: Static dictionary in code
- **Better**: Move to AI prompt for context, let AI expand dynamically
- **Why Keep**: Provides baseline medical literacy, but shouldn't be restrictive

### 3. Simple Parser Fallback (IMPROVE)
- **Current**: Regex-based line parsing
- **Better**: Use a simpler AI model (GPT-3.5) as fallback instead of regex

### 4. Question Type Detection (IMPROVE)
- **Current**: Pattern matching for BOOLEAN, NUMERIC, etc.
- **Better**: Let AI determine the appropriate question type

### 5. Domain Detection (IMPROVE)
- **Current**: Keyword matching for DEMOGRAPHICS, TREATMENT, etc.
- **Better**: AI classification with learned patterns

## Proposed AI-Driven Architecture

### Phase 1: Enhanced AI Parsing (Temperature 0.0)
```typescript
// Enhanced prompt that outputs both criteria AND questions
const ENHANCED_PROMPT = `
Parse eligibility criteria into structured data.
For each criterion, generate:
1. The structured criterion data
2. A patient-friendly question
3. The appropriate input type
4. Help text if needed

The AI should handle ALL interpretation, not patterns.
`;
```

### Phase 2: Eliminate Pattern Dependencies
```typescript
class EligibilityCheckerService {
  async parseEligibilityCriteria(trial: ClinicalTrial) {
    // Check cache first (keep caching!)
    const cached = await this.checkCache(nctId);
    if (cached) return cached;
    
    // Call enhanced AI parsing
    const result = await this.callAIParser({
      criteria: eligibilityCriteria,
      includeQuestions: true,  // AI generates questions too
      includeHelpText: true,   // AI explains medical terms
      temperature: 0.0         // Deterministic
    });
    
    // Cache the complete result
    await this.cacheResult(nctId, result);
    return result;
  }
  
  // NO MORE generateQuestions() - AI does it all!
}
```

### Phase 3: Smarter Caching Strategy
```typescript
interface CachedCriteria {
  nctId: string;
  version: string;          // Track prompt version
  criteria: InterpretedCriterion[];
  questions: EligibilityQuestion[];  // Pre-generated by AI
  medicalTerms: Record<string, string>; // AI-extracted terms
  parsedAt: Date;
  model: string;           // Track which model parsed it
}
```

### Phase 4: Flexible Assessment
Instead of hardcoded `meetsInclusionCriterion`:
```typescript
async assessEligibility(criteria, responses) {
  // Let AI assess the responses
  const assessment = await this.callAIAssessment({
    criteria,
    responses,
    prompt: `Assess if patient meets criteria based on responses.
             Consider medical nuances and edge cases.`
  });
  
  return assessment;
}
```

## Implementation Plan

### Step 1: Enhance AI Parsing Prompt
Modify `/app/api/eligibility/parse/route.ts` to:
- Generate questions directly in AI parsing
- Extract medical terms dynamically
- Determine question types intelligently

### Step 2: Remove Pattern Dependencies
- Delete `/lib/eligibility-checker/question-patterns.ts`
- Remove pattern imports from service
- Simplify service to just orchestrate AI calls

### Step 3: Improve Fallback Strategy
Instead of regex parsing:
- Use GPT-3.5-turbo as fallback (cheaper, still AI-driven)
- Or use cached results from similar trials
- Never fall back to patterns

### Step 4: Enhanced Caching
- Cache complete AI output (criteria + questions + terms)
- Version the cache based on prompt version
- Share cache across users (same trial = same questions)

### Step 5: AI-Driven Assessment
- Replace hardcoded inclusion/exclusion logic
- Let AI assess nuanced responses
- Handle "uncertain" responses intelligently

## Benefits of AI-Driven Approach

1. **Robustness**: Handles any new medical criteria without code changes
2. **Flexibility**: Adapts to novel trial designs and criteria
3. **Accuracy**: AI understands medical nuances better than patterns
4. **Maintainability**: No pattern library to maintain
5. **Scalability**: Same approach works for any medical condition

## Specific Improvements

### Remove These Hardcoded Elements:

1. **QUESTION_PATTERNS array** - Let AI generate questions
2. **detectDomain() method** - AI classifies domains
3. **determineValueType() method** - AI determines input types
4. **generateDefaultQuestion() method** - AI creates all questions
5. **simpleParser() regex logic** - Use AI fallback

### Keep But Improve:

1. **Caching** - Essential for performance, enhance it
2. **Temperature 0.0** - Keep for determinism
3. **Medical terms** - Move to prompt context, not code
4. **Assessment logic** - Make AI-driven, not rule-based

## Example: AI-Driven Question Generation

Instead of:
```typescript
// BRITTLE PATTERN
if (pattern.test(/age\s+(\d+)/)) {
  return "What is your age?";
}
```

The AI interprets:
```
Criterion: "Age â‰¥ 18 years at time of consent"
AI Output: {
  question: "What is your age at the time you would provide consent?",
  type: "NUMERIC",
  validation: { min: 18 },
  helpText: "You must be at least 18 years old to participate"
}
```

## Migration Path

1. **Phase 1** (Immediate): Keep current system but enhance AI prompt
2. **Phase 2** (Next Sprint): Remove pattern library, rely on AI
3. **Phase 3** (Future): AI-driven assessment and response interpretation

## Conclusion

The system should leverage AI's interpretive power, not constrain it with patterns. The efficiency comes from:
- **Caching AI results** (not from patterns)
- **Deterministic AI** (temperature 0.0)
- **Smart orchestration** (not hardcoded rules)

This makes the system truly robust and future-proof.